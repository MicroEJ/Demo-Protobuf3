/*
 * Java
 *
 * Copyright 2020-2022 MicroEJ Corp. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be found with this software.
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: timestamp.proto
package com.google.protobuf;

/**
 * <pre>
 * A Timestamp represents a point in time independent of any time zone or local
 * calendar, encoded as a count of seconds and fractions of seconds at
 * nanosecond resolution. The count is relative to an epoch at UTC midnight on
 * January 1, 1970, in the proleptic Gregorian calendar which extends the
 * Gregorian calendar backwards to year one.
 * All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
 * second table is needed for interpretation, using a [24-hour linear
 * smear](https://developers.google.com/time/smear).
 * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
 * restricting to that range, we ensure that we can convert to and from [RFC
 * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
 * # Examples
 * Example 1: Compute Timestamp from POSIX `time()`.
 *     Timestamp timestamp;
 *     timestamp.set_seconds(time(NULL));
 *     timestamp.set_nanos(0);
 * Example 2: Compute Timestamp from POSIX `gettimeofday()`.
 *     struct timeval tv;
 *     gettimeofday(&amp;tv, NULL);
 *     Timestamp timestamp;
 *     timestamp.set_seconds(tv.tv_sec);
 *     timestamp.set_nanos(tv.tv_usec * 1000);
 * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
 *     FILETIME ft;
 *     GetSystemTimeAsFileTime(&amp;ft);
 *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) &lt;&lt; 32) | ft.dwLowDateTime;
 *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
 *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
 *     Timestamp timestamp;
 *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
 *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
 * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
 *     long millis = System.currentTimeMillis();
 *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
 *         .setNanos((int) ((millis % 1000) * 1000000)).build();
 * Example 5: Compute Timestamp from current time in Python.
 *     timestamp = Timestamp()
 *     timestamp.GetCurrentTime()
 * # JSON Mapping
 * In JSON format, the Timestamp type is encoded as a string in the
 * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
 * format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
 * where {year} is always expressed using four digits while {month}, {day},
 * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
 * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
 * are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
 * is required. A proto3 JSON serializer should always use UTC (as indicated by
 * "Z") when printing the Timestamp type and a proto3 JSON parser should be
 * able to accept both UTC and other timezones (as indicated by an offset).
 * For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
 * 01:30 UTC on January 15, 2017.
 * In JavaScript, one can convert a Date object to this format using the
 * standard
 * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
 * method. In Python, a standard `datetime.datetime` object can be converted
 * to this format using
 * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
 * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
 * the Joda Time's [`ISODateTimeFormat.dateTime()`](
 * http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D
 * ) to obtain a formatter capable of generating timestamps in this format.
 * </pre>
 *
 * Protobuf type {@code google.protobuf.Timestamp}
 */
public final class Timestamp extends com.google.protobuf.GeneratedMessageLite<Timestamp, Timestamp.Builder> implements
		// @@protoc_insertion_point(message_implements:google.protobuf.Timestamp)
		TimestampOrBuilder {
	private Timestamp() {
	}

	public static final int SECONDS_FIELD_NUMBER = 1;
	private long seconds_;

	/**
	 * <pre>
	 * Represents seconds of UTC time since Unix epoch
	 * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
	 * 9999-12-31T23:59:59Z inclusive.
	 * </pre>
	 *
	 * <code>optional int64 seconds = 1;</code>
	 */
	@Override
	public long getSeconds() {
		return this.seconds_;
	}

	/**
	 * <pre>
	 * Represents seconds of UTC time since Unix epoch
	 * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
	 * 9999-12-31T23:59:59Z inclusive.
	 * </pre>
	 *
	 * <code>optional int64 seconds = 1;</code>
	 */
	private void setSeconds(long value) {

		this.seconds_ = value;
	}

	/**
	 * <pre>
	 * Represents seconds of UTC time since Unix epoch
	 * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
	 * 9999-12-31T23:59:59Z inclusive.
	 * </pre>
	 *
	 * <code>optional int64 seconds = 1;</code>
	 */
	private void clearSeconds() {

		this.seconds_ = 0L;
	}

	public static final int NANOS_FIELD_NUMBER = 2;
	private int nanos_;

	/**
	 * <pre>
	 * Non-negative fractions of a second at nanosecond resolution. Negative
	 * second values with fractions must still have non-negative nanos values
	 * that count forward in time. Must be from 0 to 999,999,999
	 * inclusive.
	 * </pre>
	 *
	 * <code>optional int32 nanos = 2;</code>
	 */
	@Override
	public int getNanos() {
		return this.nanos_;
	}

	/**
	 * <pre>
	 * Non-negative fractions of a second at nanosecond resolution. Negative
	 * second values with fractions must still have non-negative nanos values
	 * that count forward in time. Must be from 0 to 999,999,999
	 * inclusive.
	 * </pre>
	 *
	 * <code>optional int32 nanos = 2;</code>
	 */
	private void setNanos(int value) {

		this.nanos_ = value;
	}

	/**
	 * <pre>
	 * Non-negative fractions of a second at nanosecond resolution. Negative
	 * second values with fractions must still have non-negative nanos values
	 * that count forward in time. Must be from 0 to 999,999,999
	 * inclusive.
	 * </pre>
	 *
	 * <code>optional int32 nanos = 2;</code>
	 */
	private void clearNanos() {

		this.nanos_ = 0;
	}

	@Override
	public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
		if (this.seconds_ != 0L) {
			output.writeInt64(1, this.seconds_);
		}
		if (this.nanos_ != 0) {
			output.writeInt32(2, this.nanos_);
		}
	}

	@Override
	public int getSerializedSize() {
		int size = this.memoizedSerializedSize;
		if (size != -1) {
			return size;
		}

		size = 0;
		if (this.seconds_ != 0L) {
			size += com.google.protobuf.CodedOutputStream.computeInt64Size(1, this.seconds_);
		}
		if (this.nanos_ != 0) {
			size += com.google.protobuf.CodedOutputStream.computeInt32Size(2, this.nanos_);
		}
		this.memoizedSerializedSize = size;
		return size;
	}

	public static com.google.protobuf.Timestamp parseFrom(com.google.protobuf.ByteString data)
			throws com.google.protobuf.InvalidProtocolBufferException {
		return com.google.protobuf.GeneratedMessageLite.parseFrom(DEFAULT_INSTANCE, data);
	}

	public static com.google.protobuf.Timestamp parseFrom(com.google.protobuf.ByteString data,
			com.google.protobuf.ExtensionRegistryLite extensionRegistry)
			throws com.google.protobuf.InvalidProtocolBufferException {
		return com.google.protobuf.GeneratedMessageLite.parseFrom(DEFAULT_INSTANCE, data, extensionRegistry);
	}

	public static com.google.protobuf.Timestamp parseFrom(byte[] data)
			throws com.google.protobuf.InvalidProtocolBufferException {
		return com.google.protobuf.GeneratedMessageLite.parseFrom(DEFAULT_INSTANCE, data);
	}

	public static com.google.protobuf.Timestamp parseFrom(byte[] data,
			com.google.protobuf.ExtensionRegistryLite extensionRegistry)
			throws com.google.protobuf.InvalidProtocolBufferException {
		return com.google.protobuf.GeneratedMessageLite.parseFrom(DEFAULT_INSTANCE, data, extensionRegistry);
	}

	public static com.google.protobuf.Timestamp parseFrom(java.io.InputStream input) throws java.io.IOException {
		return com.google.protobuf.GeneratedMessageLite.parseFrom(DEFAULT_INSTANCE, input);
	}

	public static com.google.protobuf.Timestamp parseFrom(java.io.InputStream input,
			com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		return com.google.protobuf.GeneratedMessageLite.parseFrom(DEFAULT_INSTANCE, input, extensionRegistry);
	}

	public static com.google.protobuf.Timestamp parseDelimitedFrom(java.io.InputStream input)
			throws java.io.IOException {
		return parseDelimitedFrom(DEFAULT_INSTANCE, input);
	}

	public static com.google.protobuf.Timestamp parseDelimitedFrom(java.io.InputStream input,
			com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
	}

	public static com.google.protobuf.Timestamp parseFrom(com.google.protobuf.CodedInputStream input)
			throws java.io.IOException {
		return com.google.protobuf.GeneratedMessageLite.parseFrom(DEFAULT_INSTANCE, input);
	}

	public static com.google.protobuf.Timestamp parseFrom(com.google.protobuf.CodedInputStream input,
			com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		return com.google.protobuf.GeneratedMessageLite.parseFrom(DEFAULT_INSTANCE, input, extensionRegistry);
	}

	public static Builder newBuilder() {
		return DEFAULT_INSTANCE.toBuilder();
	}

	public static Builder newBuilder(com.google.protobuf.Timestamp prototype) {
		return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
	}

	/**
	 * <pre>
	 * A Timestamp represents a point in time independent of any time zone or local
	 * calendar, encoded as a count of seconds and fractions of seconds at
	 * nanosecond resolution. The count is relative to an epoch at UTC midnight on
	 * January 1, 1970, in the proleptic Gregorian calendar which extends the
	 * Gregorian calendar backwards to year one.
	 * All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
	 * second table is needed for interpretation, using a [24-hour linear
	 * smear](https://developers.google.com/time/smear).
	 * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
	 * restricting to that range, we ensure that we can convert to and from [RFC
	 * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
	 * # Examples
	 * Example 1: Compute Timestamp from POSIX `time()`.
	 *     Timestamp timestamp;
	 *     timestamp.set_seconds(time(NULL));
	 *     timestamp.set_nanos(0);
	 * Example 2: Compute Timestamp from POSIX `gettimeofday()`.
	 *     struct timeval tv;
	 *     gettimeofday(&amp;tv, NULL);
	 *     Timestamp timestamp;
	 *     timestamp.set_seconds(tv.tv_sec);
	 *     timestamp.set_nanos(tv.tv_usec * 1000);
	 * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
	 *     FILETIME ft;
	 *     GetSystemTimeAsFileTime(&amp;ft);
	 *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) &lt;&lt; 32) | ft.dwLowDateTime;
	 *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
	 *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
	 *     Timestamp timestamp;
	 *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
	 *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
	 * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
	 *     long millis = System.currentTimeMillis();
	 *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
	 *         .setNanos((int) ((millis % 1000) * 1000000)).build();
	 * Example 5: Compute Timestamp from current time in Python.
	 *     timestamp = Timestamp()
	 *     timestamp.GetCurrentTime()
	 * # JSON Mapping
	 * In JSON format, the Timestamp type is encoded as a string in the
	 * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
	 * format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
	 * where {year} is always expressed using four digits while {month}, {day},
	 * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
	 * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
	 * are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
	 * is required. A proto3 JSON serializer should always use UTC (as indicated by
	 * "Z") when printing the Timestamp type and a proto3 JSON parser should be
	 * able to accept both UTC and other timezones (as indicated by an offset).
	 * For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
	 * 01:30 UTC on January 15, 2017.
	 * In JavaScript, one can convert a Date object to this format using the
	 * standard
	 * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
	 * method. In Python, a standard `datetime.datetime` object can be converted
	 * to this format using
	 * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
	 * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
	 * the Joda Time's [`ISODateTimeFormat.dateTime()`](
	 * http://www.joda.org/joda-time/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D
	 * ) to obtain a formatter capable of generating timestamps in this format.
	 * </pre>
	 *
	 * Protobuf type {@code google.protobuf.Timestamp}
	 */
	public static final class Builder extends com.google.protobuf.GeneratedMessageLite.Builder<com.google.protobuf.Timestamp, Builder>
			implements
			// @@protoc_insertion_point(builder_implements:google.protobuf.Timestamp)
			com.google.protobuf.TimestampOrBuilder {
		// Construct using com.google.protobuf.Timestamp.newBuilder()
		private Builder() {
			super(DEFAULT_INSTANCE);
		}

		/**
		 * <pre>
		 * Represents seconds of UTC time since Unix epoch
		 * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
		 * 9999-12-31T23:59:59Z inclusive.
		 * </pre>
		 *
		 * <code>optional int64 seconds = 1;</code>
		 */
		@Override
		public long getSeconds() {
			return this.instance.getSeconds();
		}

		/**
		 * <pre>
		 * Represents seconds of UTC time since Unix epoch
		 * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
		 * 9999-12-31T23:59:59Z inclusive.
		 * </pre>
		 *
		 * <code>optional int64 seconds = 1;</code>
		 */
		public Builder setSeconds(long value) {
			copyOnWrite();
			this.instance.setSeconds(value);
			return this;
		}

		/**
		 * <pre>
		 * Represents seconds of UTC time since Unix epoch
		 * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
		 * 9999-12-31T23:59:59Z inclusive.
		 * </pre>
		 *
		 * <code>optional int64 seconds = 1;</code>
		 */
		public Builder clearSeconds() {
			copyOnWrite();
			this.instance.clearSeconds();
			return this;
		}

		/**
		 * <pre>
		 * Non-negative fractions of a second at nanosecond resolution. Negative
		 * second values with fractions must still have non-negative nanos values
		 * that count forward in time. Must be from 0 to 999,999,999
		 * inclusive.
		 * </pre>
		 *
		 * <code>optional int32 nanos = 2;</code>
		 */
		@Override
		public int getNanos() {
			return this.instance.getNanos();
		}

		/**
		 * <pre>
		 * Non-negative fractions of a second at nanosecond resolution. Negative
		 * second values with fractions must still have non-negative nanos values
		 * that count forward in time. Must be from 0 to 999,999,999
		 * inclusive.
		 * </pre>
		 *
		 * <code>optional int32 nanos = 2;</code>
		 */
		public Builder setNanos(int value) {
			copyOnWrite();
			this.instance.setNanos(value);
			return this;
		}

		/**
		 * <pre>
		 * Non-negative fractions of a second at nanosecond resolution. Negative
		 * second values with fractions must still have non-negative nanos values
		 * that count forward in time. Must be from 0 to 999,999,999
		 * inclusive.
		 * </pre>
		 *
		 * <code>optional int32 nanos = 2;</code>
		 */
		public Builder clearNanos() {
			copyOnWrite();
			this.instance.clearNanos();
			return this;
		}

		// @@protoc_insertion_point(builder_scope:google.protobuf.Timestamp)
	}

	@Override
	@java.lang.SuppressWarnings("unchecked")
	protected final Object dynamicMethod(com.google.protobuf.GeneratedMessageLite.MethodToInvoke method, Object arg0,
			Object arg1) {
		switch (method) {
		case NEW_MUTABLE_INSTANCE: {
			return new com.google.protobuf.Timestamp();
		}
		case IS_INITIALIZED: {
			return DEFAULT_INSTANCE;
		}
		case MAKE_IMMUTABLE: {
			return null;
		}
		case NEW_BUILDER: {
			return new Builder();
		}
		case VISIT: {
			Visitor visitor = (Visitor) arg0;
			com.google.protobuf.Timestamp other = (com.google.protobuf.Timestamp) arg1;
			this.seconds_ = visitor.visitLong(this.seconds_ != 0L, this.seconds_, other.seconds_ != 0L, other.seconds_);
			this.nanos_ = visitor.visitInt(this.nanos_ != 0, this.nanos_, other.nanos_ != 0, other.nanos_);
			if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor.INSTANCE) {
			}
			return this;
		}
		case MERGE_FROM_STREAM: {
			com.google.protobuf.CodedInputStream input = (com.google.protobuf.CodedInputStream) arg0;
			com.google.protobuf.ExtensionRegistryLite extensionRegistry = (com.google.protobuf.ExtensionRegistryLite) arg1;
			try {
				boolean done = false;
				while (!done) {
					int tag = input.readTag();
					switch (tag) {
					case 0:
						done = true;
						break;
					default: {
						if (!input.skipField(tag)) {
							done = true;
						}
						break;
					}
					case 8: {

						this.seconds_ = input.readInt64();
						break;
					}
					case 16: {

						this.nanos_ = input.readInt32();
						break;
					}
					}
				}
			} catch (com.google.protobuf.InvalidProtocolBufferException e) {
				throw new RuntimeException(e.setUnfinishedMessage(this));
			} catch (java.io.IOException e) {
				throw new RuntimeException(new com.google.protobuf.InvalidProtocolBufferException(e.getMessage())
						.setUnfinishedMessage(this));
			} finally {
			}
		}
		// fall through
		case GET_DEFAULT_INSTANCE: {
			return DEFAULT_INSTANCE;
		}
		case GET_PARSER: {
			if (PARSER == null) {
				synchronized (com.google.protobuf.Timestamp.class) {
					if (PARSER == null) {
						PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
					}
				}
			}
			return PARSER;
		}
		}
		throw new UnsupportedOperationException();
	}

	// @@protoc_insertion_point(class_scope:google.protobuf.Timestamp)
	private static final com.google.protobuf.Timestamp DEFAULT_INSTANCE;
	static {
		DEFAULT_INSTANCE = new Timestamp();
		DEFAULT_INSTANCE.makeImmutable();
	}

	public static com.google.protobuf.Timestamp getDefaultInstance() {
		return DEFAULT_INSTANCE;
	}

	private static volatile com.google.protobuf.Parser<Timestamp> PARSER;

	public static com.google.protobuf.Parser<Timestamp> parser() {
		return DEFAULT_INSTANCE.getParserForType();
	}
}
